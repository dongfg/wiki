<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/static/css/colorful.css">
    <link rel="Stylesheet" type="text/css" href="/static/css/style.css">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>Go 指南 - dongfg' wiki</title>
    <meta name="keywords" content="java, python, linux, docker, wiki, simiki"/>
    <meta name="description" content="dongfg' personal wiki"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
  </head>

  <body>
    <div id="container" class="typo">
      
<div id="header">
  <div id="post-nav">
    <a href="/">dongfg' wiki</a>
    &nbsp;&#187;&nbsp;
    <a href="/#go">go</a>
    &nbsp;&#187;&nbsp;Go 指南
    <span class="updated">Updated&nbsp;
    2018-01-13 09:47:55
    </span>
  </div>
</div>
<div class="clearfix"></div>
<div id="content">
  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#_1">基础</a><ul>
<li><a href="#_2">包、变量和函数</a><ul>
<li><a href="#_3">包</a></li>
<li><a href="#_4">导入</a></li>
<li><a href="#_5">导出名</a></li>
<li><a href="#_6">函数</a></li>
<li><a href="#_7">多值返回</a></li>
<li><a href="#_8">命名返回值</a></li>
<li><a href="#_9">变量</a></li>
<li><a href="#_10">初始化变量</a></li>
<li><a href="#_11">短声明变量</a></li>
<li><a href="#_12">基本类型</a></li>
<li><a href="#_13">零值</a></li>
<li><a href="#_14">类型转换</a></li>
<li><a href="#_15">类型推导</a></li>
<li><a href="#_16">常量</a></li>
<li><a href="#_17">数值常量</a></li>
</ul>
</li>
<li><a href="#_18">流程控制语句</a><ul>
<li><a href="#for">for</a></li>
<li><a href="#for-go-while">for 是 Go 的 “while”</a></li>
<li><a href="#_19">死循环</a></li>
<li><a href="#if">if</a></li>
<li><a href="#if_1">if 的便捷语句</a></li>
<li><a href="#if-else">if 和 else</a></li>
<li><a href="#switch">switch</a></li>
<li><a href="#switch_1">switch 执行顺序</a></li>
<li><a href="#switch_2">没有条件的 switch</a></li>
<li><a href="#defer">defer</a></li>
<li><a href="#defer_1">defer 栈</a></li>
</ul>
</li>
<li><a href="#_20">复杂类型</a><ul>
<li><a href="#_21">指针</a></li>
<li><a href="#_22">结构体</a></li>
<li><a href="#_23">结构体字段</a></li>
<li><a href="#_24">结构体指针</a></li>
<li><a href="#_25">结构体文法</a></li>
<li><a href="#_26">数组</a></li>
<li><a href="#slice">slice</a></li>
<li><a href="#slice-slice">slice 的 slice</a></li>
<li><a href="#slice_1">对 slice 切片</a></li>
<li><a href="#slice_2">构造slice</a></li>
<li><a href="#nil-slice">nil slice</a></li>
<li><a href="#slice_3">向 slice 添加元素</a></li>
<li><a href="#range">range</a></li>
<li><a href="#range_1">range（续）</a></li>
<li><a href="#map">map</a></li>
<li><a href="#map_1">map 的 文法</a></li>
<li><a href="#map_2">map 的文法（续）</a></li>
<li><a href="#map_3">修改 map</a></li>
<li><a href="#_27">函数值</a></li>
<li><a href="#_28">函数的闭包</a></li>
</ul>
</li>
<li><a href="#_29">方法和接口</a><ul>
<li><a href="#_30">方法</a></li>
<li><a href="#_31">方法（续）</a></li>
<li><a href="#_32">接受者为指针的方法</a></li>
<li><a href="#_33">接口</a></li>
<li><a href="#_34">隐式接口</a></li>
<li><a href="#stringers">Stringers</a></li>
<li><a href="#_35">错误</a></li>
<li><a href="#readers">Readers</a></li>
<li><a href="#web">Web 服务器</a></li>
<li><a href="#_36">图片</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_37">并发</a><ul>
<li><a href="#_38">并发</a><ul>
<li><a href="#goroutine">goroutine</a></li>
<li><a href="#channel">channel</a></li>
<li><a href="#channel_1">缓冲 channel</a></li>
<li><a href="#range-close">range 和 close</a></li>
<li><a href="#select">select</a></li>
<li><a href="#_39">默认选择</a></li>
<li><a href="#syncmutex">sync.Mutex</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<blockquote>
<p>原文内容来自 <a href="https://tour.go-zh.org">Go 指南</a></p>
</blockquote>
<h2 id="_1">基础</h2>
<h3 id="_2">包、变量和函数</h3>
<h4 id="_3">包</h4>
<p>每个 Go 程序都是由包组成的。</p>
<p>程序运行的入口是包 main 。</p>
<p>这个程序使用并导入了包 "fmt" 和 "math/rand" 。</p>
<p>按照惯例，包名与导入路径的最后一个目录一致。例如，"math/rand" 包由 package rand 语句开始。</p>
<p><strong>注意</strong>：这个程序的运行环境是确定性的，因此 rand.Intn 每次都会返回相同的数字。 （为了得到不同的随机数，需要提供一个随机数种子，参阅 rand.Seed。）</p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;math/rand&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;My favorite number is&quot;</span><span class="p">,</span> <span class="nx">rand</span><span class="p">.</span><span class="nx">Intn</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>


<h4 id="_4">导入</h4>
<p>这个代码用圆括号组合了导入，这是“打包”导入语句。</p>
<p>同样可以编写多个导入语句，例如：</p>
<div class="hlcode"><pre><span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>
<span class="kn">import</span> <span class="s">&quot;math&quot;</span>
</pre></div>


<p>不过使用打包的导入语句是更好的形式。</p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;math&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Now you have %g problems.&quot;</span><span class="p">,</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sqrt</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>


<h4 id="_5">导出名</h4>
<p>在 Go 中，首字母大写的名称是被导出的。</p>
<p>在导入包之后，你只能访问包所导出的名字，任何未导出的名字是不能被包外的代码访问的。</p>
<p>Foo 和 <code>FOO</code> 都是被导出的名称。名称 <code>foo</code> 是不会被导出的。</p>
<p>执行代码，注意编译器报的错误。</p>
<p>然后将 <code>math.pi</code> 改名为 <code>math.Pi</code> 再试着执行一下。</p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;math&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nx">pi</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="_6">函数</h4>
<p>函数可以没有参数或接受多个参数。</p>
<p>在这个例子中， add 接受两个 int 类型的参数。</p>
<p>注意类型在变量名 之后 。</p>
<p>（参考 <a href="https://blog.go-zh.org/gos-declaration-syntax">这篇关于 Go 语法定义的文章</a>了解类型以这种形式出现的原因。）<br />
当两个或多个连续的函数命名参数是同一类型，则除了最后一个类型之外，其他都可以省略。</p>
<p>在这个例子中 <code>x int, y int</code> 被缩写为 <code>x, y int</code></p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">add1</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">add2</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">add1</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="mi">13</span><span class="p">))</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">add2</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="mi">13</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>


<h4 id="_7">多值返回</h4>
<p>函数可以返回任意数量的返回值。</p>
<p>swap 函数返回了两个字符串。</p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">swap</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="nx">swap</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="s">&quot;world&quot;</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="_8">命名返回值</h4>
<p>Go 的返回值可以被命名，并且就像在函数体开头声明的变量那样使用。</p>
<p>返回值的名称应当具有一定的意义，可以作为文档使用。</p>
<p>没有参数的 return 语句返回各个返回变量的当前值。这种用法被称作“裸”返回。</p>
<p>直接返回语句仅应当用在像下面这样的短函数中。在长的函数中它们会影响代码的可读性。</p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">split</span><span class="p">(</span><span class="nx">sum</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">x</span> <span class="p">=</span> <span class="nx">sum</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">/</span> <span class="mi">9</span>
    <span class="nx">y</span> <span class="p">=</span> <span class="nx">sum</span> <span class="o">-</span> <span class="nx">x</span>
    <span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">split</span><span class="p">(</span><span class="mi">17</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>


<h4 id="_9">变量</h4>
<p>var 语句定义了一个变量的列表；跟函数的参数列表一样，类型在后面。</p>
<p>就像在这个例子中看到的一样， var 语句可以定义在包或函数级别。</p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">var</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">python</span><span class="p">,</span> <span class="nx">java</span> <span class="kt">bool</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">i</span> <span class="kt">int</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">python</span><span class="p">,</span> <span class="nx">java</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="_10">初始化变量</h4>
<p>变量定义可以包含初始值，每个变量对应一个。</p>
<p>如果初始化是使用表达式，则可以省略类型；变量从初始值中获得类型。</p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">var</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">python</span><span class="p">,</span> <span class="nx">java</span> <span class="p">=</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="s">&quot;no!&quot;</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">python</span><span class="p">,</span> <span class="nx">java</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="_11">短声明变量</h4>
<p>在函数中， <code>:=</code> 简洁赋值语句在明确类型的地方，可以用于替代 var 定义。</p>
<p>函数外的每个语句都必须以关键字开始（ var 、 func 、等等）， := 结构不能使用在函数外。</p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
    <span class="nx">k</span> <span class="o">:=</span> <span class="mi">3</span>
    <span class="nx">c</span><span class="p">,</span> <span class="nx">python</span><span class="p">,</span> <span class="nx">java</span> <span class="o">:=</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="s">&quot;no!&quot;</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">python</span><span class="p">,</span> <span class="nx">java</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="_12">基本类型</h4>
<p>Go 的基本类型有Basic types</p>
<div class="hlcode"><pre><span class="kt">bool</span>

<span class="kt">string</span>

<span class="kt">int</span>  <span class="kt">int8</span>  <span class="kt">int16</span>  <span class="kt">int32</span>  <span class="kt">int64</span>
<span class="kt">uint</span> <span class="kt">uint8</span> <span class="kt">uint16</span> <span class="kt">uint32</span> <span class="kt">uint64</span> <span class="kt">uintptr</span>

<span class="kt">byte</span> <span class="c1">// uint8 的别名</span>

<span class="kt">rune</span> <span class="c1">// int32 的别名</span>
     <span class="c1">// 代表一个Unicode码</span>

<span class="kt">float32</span> <span class="kt">float64</span>

<span class="kt">complex64</span> <span class="kt">complex128</span>
</pre></div>


<p>这个例子演示了具有不同类型的变量。 同时与导入语句一样，变量的定义“打包”在一个语法块中。</p>
<p>int，uint 和 uintptr 类型在32位的系统上一般是32位，而在64位系统上是64位。当你需要使用一个整数类型时，你应该首选 int，仅当有特别的理由才使用定长整数类型或者无符号整数类型。</p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;math/cmplx&quot;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
    <span class="nx">ToBe</span>   <span class="kt">bool</span>       <span class="p">=</span> <span class="kc">false</span>
    <span class="nx">MaxInt</span> <span class="kt">uint64</span>     <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">64</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="nx">z</span>      <span class="kt">complex128</span> <span class="p">=</span> <span class="nx">cmplx</span><span class="p">.</span><span class="nx">Sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span> <span class="o">+</span> <span class="m">12i</span><span class="p">)</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">f</span> <span class="p">=</span> <span class="s">&quot;%T(%v)\n&quot;</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">ToBe</span><span class="p">,</span> <span class="nx">ToBe</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">MaxInt</span><span class="p">,</span> <span class="nx">MaxInt</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">z</span><span class="p">,</span> <span class="nx">z</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="_13">零值</h4>
<p>变量在定义时没有明确的初始化时会赋值为 零值 。</p>
<p>零值是：</p>
<p>数值类型为 0 ，<br />
布尔类型为 false ，<br />
字符串为 "" （空字符串）。</p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">i</span> <span class="kt">int</span>
    <span class="kd">var</span> <span class="nx">f</span> <span class="kt">float64</span>
    <span class="kd">var</span> <span class="nx">b</span> <span class="kt">bool</span>
    <span class="kd">var</span> <span class="nx">s</span> <span class="kt">string</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%v %v %v %q\n&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">f</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="_14">类型转换</h4>
<p>表达式 T(v) 将值 v 转换为类型 T 。</p>
<p>一些关于数值的转换：</p>
<div class="hlcode"><pre><span class="kd">var</span> <span class="nx">i</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">42</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="kt">float64</span> <span class="p">=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">u</span> <span class="kt">uint</span> <span class="p">=</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
</pre></div>


<p>或者，更加简单的形式：</p>
<div class="hlcode"><pre><span class="nx">i</span> <span class="o">:=</span> <span class="mi">42</span>
<span class="nx">f</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="nx">u</span> <span class="o">:=</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
</pre></div>


<p>与 C 不同的是 Go 的在不同类型之间的项目赋值时需要显式转换。 试着移除例子中 float64 或 int 的转换看看会发生什么。</p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;math&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span>
    <span class="kd">var</span> <span class="nx">f</span> <span class="kt">float64</span> <span class="p">=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sqrt</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">x</span><span class="o">*</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="o">*</span><span class="nx">y</span><span class="p">))</span>
    <span class="kd">var</span> <span class="nx">z</span> <span class="kt">uint</span> <span class="p">=</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="_15">类型推导</h4>
<p>在定义一个变量却并不显式指定其类型时（使用 := 语法或者 var = 表达式语法）， 变量的类型由（等号）右侧的值推导得出。</p>
<p>当右值定义了类型时，新变量的类型与其相同：</p>
<div class="hlcode"><pre><span class="kd">var</span> <span class="nx">i</span> <span class="kt">int</span>
<span class="nx">j</span> <span class="o">:=</span> <span class="nx">i</span> <span class="c1">// j 也是一个 int</span>
</pre></div>


<p>但是当右边包含了未指名类型的数字常量时，新的变量就可能是 int 、 float64 或 complex128 。 这取决于常量的精度：</p>
<div class="hlcode"><pre><span class="nx">i</span> <span class="o">:=</span> <span class="mi">42</span>           <span class="c1">// int</span>
<span class="nx">f</span> <span class="o">:=</span> <span class="mf">3.142</span>        <span class="c1">// float64</span>
<span class="nx">g</span> <span class="o">:=</span> <span class="mf">0.867</span> <span class="o">+</span> <span class="m">0.5i</span> <span class="c1">// complex128</span>
</pre></div>


<p>尝试修改演示代码中 v 的初始值，并观察这是如何影响其类型的。</p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">v</span> <span class="o">:=</span> <span class="mi">42</span> <span class="c1">// change me!</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;v is of type %T\n&quot;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="_16">常量</h4>
<p>常量的定义与变量类似，只不过使用 const 关键字。</p>
<p>常量可以是字符、字符串、布尔或数字类型的值。</p>
<p>常量不能使用 := 语法定义。</p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">const</span> <span class="nx">Pi</span> <span class="p">=</span> <span class="mf">3.14</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">World</span> <span class="p">=</span> <span class="s">&quot;世界&quot;</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">,</span> <span class="nx">World</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Happy&quot;</span><span class="p">,</span> <span class="nx">Pi</span><span class="p">,</span> <span class="s">&quot;Day&quot;</span><span class="p">)</span>

    <span class="kd">const</span> <span class="nx">Truth</span> <span class="p">=</span> <span class="kc">true</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Go rules?&quot;</span><span class="p">,</span> <span class="nx">Truth</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="_17">数值常量</h4>
<p>数值常量是高精度的 值 。</p>
<p>一个未指定类型的常量由上下文来决定其类型。</p>
<p>也尝试一下输出 needInt(Big) 吧。</p>
<p>（int 可以存放最大64位的整数，根据平台不同有时会更少。）</p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">const</span> <span class="p">(</span>
    <span class="nx">Big</span>   <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">100</span>
    <span class="nx">Small</span> <span class="p">=</span> <span class="nx">Big</span> <span class="o">&gt;&gt;</span> <span class="mi">99</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">needInt</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nx">needFloat</span><span class="p">(</span><span class="nx">x</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="mf">0.1</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">needInt</span><span class="p">(</span><span class="nx">Small</span><span class="p">))</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">needFloat</span><span class="p">(</span><span class="nx">Small</span><span class="p">))</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">needFloat</span><span class="p">(</span><span class="nx">Big</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>


<h3 id="_18">流程控制语句</h3>
<h4 id="for">for</h4>
<p>Go 只有一种循环结构—— for 循环。</p>
<p>基本的 for 循环包含三个由分号分开的组成部分：</p>
<p>初始化语句：在第一次循环执行前被执行<br />
循环条件表达式：每轮迭代开始前被求值<br />
后置语句：每轮迭代后被执行<br />
初始化语句一般是一个短变量声明，这里声明的变量仅在整个 for 循环语句可见。</p>
<p>如果条件表达式的值变为 false，那么迭代将终止。</p>
<blockquote>
<p>注意：不像 C，Java，或者 Javascript 等其他语言，for 语句的三个组成部分 并不需要用括号括起来，但循环体必须用 { } 括起来。  </p>
</blockquote>
<p>循环初始化语句和后置语句都是可选的。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">i</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">sum</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">;</span> <span class="nx">sum</span> <span class="p">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="p">{</span>
        <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">sum</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">sum</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="for-go-while">for 是 Go 的 “while”</h4>
<p>基于此可以省略分号：C 的 <code>while</code> 在 Go 中叫做 <code>for</code> 。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="nx">sum</span> <span class="p">&lt;</span> <span class="mi">1000</span> <span class="p">{</span>
        <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">sum</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">sum</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="_19">死循环</h4>
<p>如果省略了循环条件，循环就不会结束，因此可以用更简洁地形式表达死循环。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h4 id="if">if</h4>
<p>就像 for 循环一样，Go 的 if 语句也不要求用 ( ) 将条件括起来，同时， { } 还是必须有的。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;math&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">sqrt</span><span class="p">(</span><span class="nx">x</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">x</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">sqrt</span><span class="p">(</span><span class="o">-</span><span class="nx">x</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;i&quot;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprint</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nx">Sqrt</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="nx">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>


<h4 id="if_1">if 的便捷语句</h4>
<p>跟 for 一样， if 语句可以在条件之前执行一个简单语句。</p>
<p>由这个语句定义的变量的作用域仅在 if 范围之内。</p>
<p>（在最后的 return 语句处使用 v 看看。）  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;math&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">pow</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">lim</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">v</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Pow</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">n</span><span class="p">);</span> <span class="nx">v</span> <span class="p">&lt;</span> <span class="nx">lim</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">v</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">lim</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span>
        <span class="nx">pow</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
        <span class="nx">pow</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span>
    <span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="if-else">if 和 else</h4>
<p>在 if 的便捷语句定义的变量同样可以在任何对应的 else 块中使用。</p>
<p>（提示：两个 pow 调用都在 main 调用 fmt.Println 前执行完毕了。）   </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;math&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">pow</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">lim</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">v</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Pow</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">n</span><span class="p">);</span> <span class="nx">v</span> <span class="p">&lt;</span> <span class="nx">lim</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">v</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%g &gt;= %g\n&quot;</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">lim</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// 这里开始就不能使用 v 了</span>
    <span class="k">return</span> <span class="nx">lim</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span>
        <span class="nx">pow</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
        <span class="nx">pow</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span>
    <span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="switch">switch</h4>
<p>你可能已经知道 switch 语句会长什么样了。</p>
<p>除非以 fallthrough 语句结束，否则分支会自动终止。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;runtime&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Print</span><span class="p">(</span><span class="s">&quot;Go runs on &quot;</span><span class="p">)</span>
    <span class="k">switch</span> <span class="nx">os</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">GOOS</span><span class="p">;</span> <span class="nx">os</span> <span class="p">{</span>
    <span class="k">case</span> <span class="s">&quot;darwin&quot;</span><span class="p">:</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;OS X.&quot;</span><span class="p">)</span>
    <span class="k">case</span> <span class="s">&quot;linux&quot;</span><span class="p">:</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Linux.&quot;</span><span class="p">)</span>
    <span class="k">default</span><span class="p">:</span>
        <span class="c1">// freebsd, openbsd,</span>
        <span class="c1">// plan9, windows...</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s.&quot;</span><span class="p">,</span> <span class="nx">os</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h4 id="switch_1">switch 执行顺序</h4>
<p>switch 的条件从上到下的执行，当匹配成功的时候停止。<br />
（例如，</p>
<div class="hlcode"><pre><span class="k">switch</span> <span class="nx">i</span> <span class="p">{</span>
<span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
<span class="k">case</span> <span class="nx">f</span><span class="p">():</span>
<span class="p">}</span>
</pre></div>


<p>当 i==0 时不会调用 f 。）</p>
<p>注意：Go playground 中的时间总是从 2009-11-10 23:00:00 UTC 开始， 如何校验这个值作为一个练习留给读者完成。</p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;time&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;When&#39;s Saturday?&quot;</span><span class="p">)</span>
    <span class="nx">today</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">().</span><span class="nx">Weekday</span><span class="p">()</span>
    <span class="k">switch</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Saturday</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">today</span> <span class="o">+</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Today.&quot;</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">today</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Tomorrow.&quot;</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">today</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;In two days.&quot;</span><span class="p">)</span>
    <span class="k">default</span><span class="p">:</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Too far away.&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h4 id="switch_2">没有条件的 switch</h4>
<p>没有条件的 switch 同 switch true 一样。</p>
<p>这一构造使得可以用更清晰的形式来编写长的 if-then-else 链。</p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;time&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">t</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">()</span>
    <span class="k">switch</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Hour</span><span class="p">()</span> <span class="p">&lt;</span> <span class="mi">12</span><span class="p">:</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Good morning!&quot;</span><span class="p">)</span>
    <span class="k">case</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Hour</span><span class="p">()</span> <span class="p">&lt;</span> <span class="mi">17</span><span class="p">:</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Good afternoon.&quot;</span><span class="p">)</span>
    <span class="k">default</span><span class="p">:</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Good evening.&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h4 id="defer">defer</h4>
<p>defer 语句会延迟函数的执行直到上层函数返回。</p>
<p>延迟调用的参数会立刻生成，但是在上层函数返回前函数都不会被调用。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;world&quot;</span><span class="p">)</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="defer_1">defer 栈</h4>
<p>延迟的函数调用被压入一个栈中。当函数返回时， 会按照后进先出的顺序调用被延迟的函数调用。</p>
<p>阅读<a href="http://blog.go-zh.org/defer-panic-and-recover">博文</a>了解更多关于 defer 语句的信息。</p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;counting&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;done&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h3 id="_20">复杂类型</h3>
<h4 id="_21">指针</h4>
<p>Go 具有指针。 指针保存了变量的内存地址。</p>
<p>类型 *T 是指向类型 T 的值的指针。其零值是 nil 。</p>
<div class="hlcode"><pre><span class="kd">var</span> <span class="nx">p</span> <span class="o">*</span><span class="kt">int</span>
</pre></div>


<p>&amp; 符号会生成一个指向其作用对象的指针。</p>
<div class="hlcode"><pre><span class="nx">i</span> <span class="o">:=</span> <span class="mi">42</span>
<span class="nx">p</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">i</span>
</pre></div>


<ul>
<li>符号表示指针指向的底层的值。</li>
</ul>
<div class="hlcode"><pre><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// 通过指针 p 读取 i</span>
<span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="mi">21</span>         <span class="c1">// 通过指针 p 设置 i</span>
</pre></div>


<p>这也就是通常所说的“间接引用”或“非直接引用”。</p>
<p>与 C 不同，Go 没有指针运算。</p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">2701</span>

    <span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">i</span>         <span class="c1">// point to i</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// read i through the pointer</span>
    <span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="mi">21</span>         <span class="c1">// set i through the pointer</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>  <span class="c1">// see the new value of i</span>

    <span class="nx">p</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">j</span>         <span class="c1">// point to j</span>
    <span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="o">*</span><span class="nx">p</span> <span class="o">/</span> <span class="mi">37</span>   <span class="c1">// divide j through the pointer</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">j</span><span class="p">)</span> <span class="c1">// see the new value of j</span>
<span class="p">}</span>
</pre></div>


<h4 id="_22">结构体</h4>
<p>一个结构体（ struct ）就是一个字段的集合。</p>
<p>（而 type 的含义跟其字面意思相符。）  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">type</span> <span class="nx">Vertex</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">X</span> <span class="kt">int</span>
    <span class="nx">Y</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">Vertex</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">})</span>
<span class="p">}</span>
</pre></div>


<h4 id="_23">结构体字段</h4>
<p>结构体字段使用点号来访问。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">type</span> <span class="nx">Vertex</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">X</span> <span class="kt">int</span>
    <span class="nx">Y</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">v</span> <span class="o">:=</span> <span class="nx">Vertex</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
    <span class="nx">v</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="mi">4</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">X</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="_24">结构体指针</h4>
<p>结构体字段可以通过结构体指针来访问。</p>
<p>通过指针间接的访问是透明的。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">type</span> <span class="nx">Vertex</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">X</span> <span class="kt">int</span>
    <span class="nx">Y</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">v</span> <span class="o">:=</span> <span class="nx">Vertex</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
    <span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">v</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="mf">1e9</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="_25">结构体文法</h4>
<p>结构体文法表示通过结构体字段的值作为列表来新分配一个结构体。</p>
<p>使用 Name: 语法可以仅列出部分字段。（字段名的顺序无关。）</p>
<p>特殊的前缀 &amp; 返回一个指向结构体的指针。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">type</span> <span class="nx">Vertex</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="p">(</span>
    <span class="nx">v1</span> <span class="p">=</span> <span class="nx">Vertex</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>  <span class="c1">// 类型为 Vertex</span>
    <span class="nx">v2</span> <span class="p">=</span> <span class="nx">Vertex</span><span class="p">{</span><span class="nx">X</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>  <span class="c1">// Y:0 被省略</span>
    <span class="nx">v3</span> <span class="p">=</span> <span class="nx">Vertex</span><span class="p">{}</span>      <span class="c1">// X:0 和 Y:0</span>
    <span class="nx">p</span>  <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Vertex</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span> <span class="c1">// 类型为 *Vertex</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">v1</span><span class="p">,</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">v2</span><span class="p">,</span> <span class="nx">v3</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="_26">数组</h4>
<p>类型 [n]T 是一个有 n 个类型为 T 的值的数组。</p>
<p>表达式</p>
<p>var a [10]int<br />
定义变量 a 是一个有十个整数的数组。</p>
<p>数组的长度是其类型的一部分，因此数组不能改变大小。 这看起来是一个制约，但是请不要担心； Go 提供了更加便利的方式来使用数组。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">string</span>
    <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="s">&quot;Hello&quot;</span>
    <span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="s">&quot;World&quot;</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="slice">slice</h4>
<p>一个 slice 会指向一个序列的值，并且包含了长度信息。</p>
<p>[]T 是一个元素类型为 T 的 slice。</p>
<p>len(s) 返回 slice s 的长度。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;s ==&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>

    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;s[%d] == %d\n&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h4 id="slice-slice">slice 的 slice</h4>
<p>slice 可以包含任意的类型，包括另一个 slice。</p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;strings&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Create a tic-tac-toe board.</span>
    <span class="nx">game</span> <span class="o">:=</span> <span class="p">[][]</span><span class="kt">string</span><span class="p">{</span>
        <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;_&quot;</span><span class="p">,</span> <span class="s">&quot;_&quot;</span><span class="p">,</span> <span class="s">&quot;_&quot;</span><span class="p">},</span>
        <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;_&quot;</span><span class="p">,</span> <span class="s">&quot;_&quot;</span><span class="p">,</span> <span class="s">&quot;_&quot;</span><span class="p">},</span>
        <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;_&quot;</span><span class="p">,</span> <span class="s">&quot;_&quot;</span><span class="p">,</span> <span class="s">&quot;_&quot;</span><span class="p">},</span>
    <span class="p">}</span>

    <span class="c1">// The players take turns.</span>
    <span class="nx">game</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="s">&quot;X&quot;</span>
    <span class="nx">game</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="s">&quot;O&quot;</span>
    <span class="nx">game</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="s">&quot;X&quot;</span>
    <span class="nx">game</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="s">&quot;O&quot;</span>
    <span class="nx">game</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="s">&quot;X&quot;</span>

    <span class="nx">printBoard</span><span class="p">(</span><span class="nx">game</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">printBoard</span><span class="p">(</span><span class="nx">s</span> <span class="p">[][]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s\n&quot;</span><span class="p">,</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">Join</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="s">&quot; &quot;</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h4 id="slice_1">对 slice 切片</h4>
<p>slice 可以重新切片，创建一个新的 slice 值指向相同的数组。</p>
<p>表达式</p>
<div class="hlcode"><pre><span class="nx">s</span><span class="p">[</span><span class="nx">lo</span><span class="p">:</span><span class="nx">hi</span><span class="p">]</span>
</pre></div>


<p>表示从 lo 到 hi-1 的 slice 元素，含前端，不包含后端。因此</p>
<div class="hlcode"><pre><span class="nx">s</span><span class="p">[</span><span class="nx">lo</span><span class="p">:</span><span class="nx">lo</span><span class="p">]</span>
</pre></div>


<p>是空的，而</p>
<div class="hlcode"><pre><span class="nx">s</span><span class="p">[</span><span class="nx">lo</span><span class="p">:</span><span class="nx">lo</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</pre></div>


<p>有一个元素。</p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;s ==&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;s[1:4] ==&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>

    <span class="c1">// 省略下标代表从 0 开始</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;s[:3] ==&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span>

    <span class="c1">// 省略上标代表到 len(s) 结束</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;s[4:] ==&quot;</span><span class="p">,</span> <span class="nx">s</span><span class="p">[</span><span class="mi">4</span><span class="p">:])</span>
<span class="p">}</span>
</pre></div>


<h4 id="slice_2">构造slice</h4>
<p>slice 由函数 make 创建。这会分配一个全是零值的数组并且返回一个 slice 指向这个数组：  </p>
<div class="hlcode"><pre><span class="nx">a</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1">// len(a)=5</span>
</pre></div>


<p>为了指定容量，可传递第三个参数到 make：   </p>
<div class="hlcode"><pre><span class="nx">b</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">// len(b)=0, cap(b)=5</span>

<span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">[:</span><span class="nb">cap</span><span class="p">(</span><span class="nx">b</span><span class="p">)]</span> <span class="c1">// len(b)=5, cap(b)=5</span>
<span class="nx">b</span> <span class="p">=</span> <span class="nx">b</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>      <span class="c1">// len(b)=4, cap(b)=4</span>
</pre></div>


<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">a</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="nx">printSlice</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
    <span class="nx">b</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="nx">printSlice</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
    <span class="nx">c</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="nx">printSlice</span><span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
    <span class="nx">d</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
    <span class="nx">printSlice</span><span class="p">(</span><span class="s">&quot;d&quot;</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">printSlice</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">x</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s len=%d cap=%d %v\n&quot;</span><span class="p">,</span>
        <span class="nx">s</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">x</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="nil-slice">nil slice</h4>
<p>slice 的零值是 nil 。</p>
<p>一个 nil 的 slice 的长度和容量是 0。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">z</span> <span class="p">[]</span><span class="kt">int</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">z</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">z</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">z</span><span class="p">))</span>
    <span class="k">if</span> <span class="nx">z</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;nil!&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h4 id="slice_3">向 slice 添加元素</h4>
<p>向 slice 的末尾添加元素是一种常见的操作，因此 Go 提供了一个内建函数 append 。 内建函数的文档对 append 有详细介绍。</p>
<p>func append(s []T, vs ...T) []T<br />
append 的第一个参数 s 是一个元素类型为 T 的 slice ，其余类型为 T 的值将会附加到该 slice 的末尾。</p>
<p>append 的结果是一个包含原 slice 所有元素加上新添加的元素的 slice。</p>
<p>如果 s 的底层数组太小，而不能容纳所有值时，会分配一个更大的数组。 返回的 slice 会指向这个新分配的数组。</p>
<p>（了解更多关于 slice 的内容，参阅文章<a href="https://blog.go-zh.org/go-slices-usage-and-internals">Go 切片：用法和本质</a>。）  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span>
    <span class="nx">printSlice</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>

    <span class="c1">// append works on nil slices.</span>
    <span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nx">printSlice</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>

    <span class="c1">// the slice grows as needed.</span>
    <span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nx">printSlice</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>

    <span class="c1">// we can add more than one element at a time.</span>
    <span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="nx">printSlice</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">printSlice</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">x</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s len=%d cap=%d %v\n&quot;</span><span class="p">,</span>
        <span class="nx">s</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">x</span><span class="p">),</span> <span class="nx">x</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="range">range</h4>
<p>for 循环的 range 格式可以对 slice 或者 map 进行迭代循环。</p>
<p>当使用 for 循环遍历一个 slice 时，每次迭代 range 将返回两个值。 第一个是当前下标（序号），第二个是该下标所对应元素的一个拷贝。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">var</span> <span class="nx">pow</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pow</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;2**%d = %d\n&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h4 id="range_1">range（续）</h4>
<p>可以通过赋值给 _ 来忽略序号和值。</p>
<p>如果只需要索引值，去掉 “ <code>, value</code> ” 的部分即可。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">pow</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pow</span> <span class="p">{</span>
        <span class="nx">pow</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">value</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pow</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%d\n&quot;</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h4 id="map">map</h4>
<p>map 映射键到值。</p>
<p>map 在使用之前必须用 make 来创建；值为 nil 的 map 是空的，并且不能对其赋值。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">type</span> <span class="nx">Vertex</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Lat</span><span class="p">,</span> <span class="nx">Long</span> <span class="kt">float64</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">m</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">Vertex</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">m</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">Vertex</span><span class="p">)</span>
    <span class="nx">m</span><span class="p">[</span><span class="s">&quot;Bell Labs&quot;</span><span class="p">]</span> <span class="p">=</span> <span class="nx">Vertex</span><span class="p">{</span>
        <span class="mf">40.68433</span><span class="p">,</span> <span class="o">-</span><span class="mf">74.39967</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">[</span><span class="s">&quot;Bell Labs&quot;</span><span class="p">])</span>
<span class="p">}</span>
</pre></div>


<h4 id="map_1">map 的 文法</h4>
<p>map 的文法跟结构体文法相似，不过必须有键名。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">type</span> <span class="nx">Vertex</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Lat</span><span class="p">,</span> <span class="nx">Long</span> <span class="kt">float64</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">m</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">Vertex</span><span class="p">{</span>
    <span class="s">&quot;Bell Labs&quot;</span><span class="p">:</span> <span class="nx">Vertex</span><span class="p">{</span>
        <span class="mf">40.68433</span><span class="p">,</span> <span class="o">-</span><span class="mf">74.39967</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s">&quot;Google&quot;</span><span class="p">:</span> <span class="nx">Vertex</span><span class="p">{</span>
        <span class="mf">37.42202</span><span class="p">,</span> <span class="o">-</span><span class="mf">122.08408</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="map_2">map 的文法（续）</h4>
<p>若顶级类型只是一个类型名，你可以在文法的元素中省略它。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">type</span> <span class="nx">Vertex</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Lat</span><span class="p">,</span> <span class="nx">Long</span> <span class="kt">float64</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">m</span> <span class="p">=</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">Vertex</span><span class="p">{</span>
    <span class="s">&quot;Bell Labs&quot;</span><span class="p">:</span> <span class="p">{</span><span class="mf">40.68433</span><span class="p">,</span> <span class="o">-</span><span class="mf">74.39967</span><span class="p">},</span>
    <span class="s">&quot;Google&quot;</span><span class="p">:</span>    <span class="p">{</span><span class="mf">37.42202</span><span class="p">,</span> <span class="o">-</span><span class="mf">122.08408</span><span class="p">},</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="map_3">修改 map</h4>
<p>在 map m 中插入或修改一个元素：</p>
<div class="hlcode"><pre><span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">elem</span>
</pre></div>


<p>获得元素：</p>
<div class="hlcode"><pre><span class="nx">elem</span> <span class="p">=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
</pre></div>


<p>删除元素：</p>
<div class="hlcode"><pre><span class="nb">delete</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span>
</pre></div>


<p>通过双赋值检测某个键存在：</p>
<div class="hlcode"><pre><span class="nx">elem</span><span class="p">,</span> <span class="nx">ok</span> <span class="p">=</span> <span class="nx">m</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
</pre></div>


<p>如果 key 在 m 中， ok 为 true。否则， ok 为 false，并且 elem 是 map 的元素类型的零值。</p>
<p>同样的，当从 map 中读取某个不存在的键时，结果是 map 的元素类型的零值。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)</span>

    <span class="nx">m</span><span class="p">[</span><span class="s">&quot;Answer&quot;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">42</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;The value:&quot;</span><span class="p">,</span> <span class="nx">m</span><span class="p">[</span><span class="s">&quot;Answer&quot;</span><span class="p">])</span>

    <span class="nx">m</span><span class="p">[</span><span class="s">&quot;Answer&quot;</span><span class="p">]</span> <span class="p">=</span> <span class="mi">48</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;The value:&quot;</span><span class="p">,</span> <span class="nx">m</span><span class="p">[</span><span class="s">&quot;Answer&quot;</span><span class="p">])</span>

    <span class="nb">delete</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="s">&quot;Answer&quot;</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;The value:&quot;</span><span class="p">,</span> <span class="nx">m</span><span class="p">[</span><span class="s">&quot;Answer&quot;</span><span class="p">])</span>

    <span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">[</span><span class="s">&quot;Answer&quot;</span><span class="p">]</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;The value:&quot;</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="s">&quot;Present?&quot;</span><span class="p">,</span> <span class="nx">ok</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="_27">函数值</h4>
<p>函数也是值。他们可以像其他值一样传递，比如，函数值可以作为函数的参数或者返回值。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;math&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">compute</span><span class="p">(</span><span class="nx">fn</span> <span class="kd">func</span><span class="p">(</span><span class="kt">float64</span><span class="p">,</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fn</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">hypot</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sqrt</span><span class="p">(</span><span class="nx">x</span><span class="o">*</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="o">*</span><span class="nx">y</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">hypot</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">compute</span><span class="p">(</span><span class="nx">hypot</span><span class="p">))</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">compute</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nx">Pow</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>


<h4 id="_28">函数的闭包</h4>
<p>Go 函数可以是一个闭包。闭包是一个函数值，它引用了函数体之外的变量。 这个函数可以对这个引用的变量进行访问和赋值；换句话说这个函数被“绑定”在这个变量上。</p>
<p>例如，函数 <code>adder</code> 返回一个闭包。每个返回的闭包都被绑定到其各自的 <code>sum</code> 变量上。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">adder</span><span class="p">()</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="kd">func</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
        <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">x</span>
        <span class="k">return</span> <span class="nx">sum</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">pos</span><span class="p">,</span> <span class="nx">neg</span> <span class="o">:=</span> <span class="nx">adder</span><span class="p">(),</span> <span class="nx">adder</span><span class="p">()</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span>
            <span class="nx">pos</span><span class="p">(</span><span class="nx">i</span><span class="p">),</span>
            <span class="nx">neg</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="nx">i</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h3 id="_29">方法和接口</h3>
<h4 id="_30">方法</h4>
<p>Go 没有类。然而，仍然可以在结构体类型上定义方法。</p>
<p>方法接收者 出现在 func 关键字和方法名之间的参数中。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;math&quot;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Vertex</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">float64</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Vertex</span><span class="p">)</span> <span class="nx">Abs</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sqrt</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">X</span><span class="o">*</span><span class="nx">v</span><span class="p">.</span><span class="nx">X</span> <span class="o">+</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Y</span><span class="o">*</span><span class="nx">v</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">v</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Vertex</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">Abs</span><span class="p">())</span>
<span class="p">}</span>
</pre></div>


<h4 id="_31">方法（续）</h4>
<p>你可以对包中的 任意 类型定义任意方法，而不仅仅是针对结构体。</p>
<p>但是，不能对来自其他包的类型或基础类型定义方法。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;math&quot;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">MyFloat</span> <span class="kt">float64</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">MyFloat</span><span class="p">)</span> <span class="nx">Abs</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">f</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">float64</span><span class="p">(</span><span class="o">-</span><span class="nx">f</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">f</span> <span class="o">:=</span> <span class="nx">MyFloat</span><span class="p">(</span><span class="o">-</span><span class="nx">math</span><span class="p">.</span><span class="nx">Sqrt2</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">Abs</span><span class="p">())</span>
<span class="p">}</span>
</pre></div>


<h4 id="_32">接受者为指针的方法</h4>
<p>方法可以与命名类型或命名类型的指针关联。</p>
<p>刚刚看到的两个 Abs 方法。一个是在 *Vertex 指针类型上，而另一个在 MyFloat 值类型上。 有两个原因需要使用指针接收者。首先避免在每个方法调用中拷贝值（如果值类型是大的结构体的话会更有效率）。其次，方法可以修改接收者指向的值。</p>
<p>尝试修改 Abs 的定义，同时 Scale 方法使用 Vertex 代替 *Vertex 作为接收者。</p>
<p>当 v 是 Vertex 的时候 Scale 方法没有任何作用。Scale 修改 v。当 v 是一个值（非指针），方法看到的是 Vertex 的副本，并且无法修改原始值。</p>
<p>Abs 的工作方式是一样的。只不过，仅仅读取 v。所以读取的是原始值（通过指针）还是那个值的副本并没有关系。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;math&quot;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Vertex</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">float64</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Vertex</span><span class="p">)</span> <span class="nx">Scale</span><span class="p">(</span><span class="nx">f</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">v</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">X</span> <span class="o">*</span> <span class="nx">f</span>
    <span class="nx">v</span><span class="p">.</span><span class="nx">Y</span> <span class="p">=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Y</span> <span class="o">*</span> <span class="nx">f</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Vertex</span><span class="p">)</span> <span class="nx">Abs</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sqrt</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">X</span><span class="o">*</span><span class="nx">v</span><span class="p">.</span><span class="nx">X</span> <span class="o">+</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Y</span><span class="o">*</span><span class="nx">v</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">v</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Vertex</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Before scaling: %+v, Abs: %v\n&quot;</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Abs</span><span class="p">())</span>
    <span class="nx">v</span><span class="p">.</span><span class="nx">Scale</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;After scaling: %+v, Abs: %v\n&quot;</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Abs</span><span class="p">())</span>
<span class="p">}</span>
</pre></div>


<h4 id="_33">接口</h4>
<p>接口类型是由一组方法定义的集合。</p>
<p>接口类型的值可以存放实现这些方法的任何值。</p>
<p>注意： 示例代码的 22 行存在一个错误。 由于 Abs 只定义在 *Vertex（指针类型）上， 所以 Vertex（值类型）不满足 Abser。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;math&quot;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Abser</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Abs</span><span class="p">()</span> <span class="kt">float64</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="nx">Abser</span>
    <span class="nx">f</span> <span class="o">:=</span> <span class="nx">MyFloat</span><span class="p">(</span><span class="o">-</span><span class="nx">math</span><span class="p">.</span><span class="nx">Sqrt2</span><span class="p">)</span>
    <span class="nx">v</span> <span class="o">:=</span> <span class="nx">Vertex</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>

    <span class="nx">a</span> <span class="p">=</span> <span class="nx">f</span>  <span class="c1">// a MyFloat 实现了 Abser</span>
    <span class="nx">a</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">v</span> <span class="c1">// a *Vertex 实现了 Abser</span>

    <span class="c1">// 下面一行，v 是一个 Vertex（而不是 *Vertex）</span>
    <span class="c1">// 所以没有实现 Abser。</span>
    <span class="nx">a</span> <span class="p">=</span> <span class="nx">v</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">Abs</span><span class="p">())</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">MyFloat</span> <span class="kt">float64</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">MyFloat</span><span class="p">)</span> <span class="nx">Abs</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">f</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">float64</span><span class="p">(</span><span class="o">-</span><span class="nx">f</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Vertex</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">float64</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Vertex</span><span class="p">)</span> <span class="nx">Abs</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nx">Sqrt</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">X</span><span class="o">*</span><span class="nx">v</span><span class="p">.</span><span class="nx">X</span> <span class="o">+</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Y</span><span class="o">*</span><span class="nx">v</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="_34">隐式接口</h4>
<p>类型通过实现那些方法来实现接口。 没有显式声明的必要；所以也就没有关键字“implements“。</p>
<p>隐式接口解藕了实现接口的包和定义接口的包：互不依赖。</p>
<p>因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。</p>
<p>包 io 定义了 Reader 和 Writer；其实不一定要这么做。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;os&quot;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Reader</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Read</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Writer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Write</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ReadWriter</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Reader</span>
    <span class="nx">Writer</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">w</span> <span class="nx">Writer</span>

    <span class="c1">// os.Stdout 实现了 Writer</span>
    <span class="nx">w</span> <span class="p">=</span> <span class="nx">os</span><span class="p">.</span><span class="nx">Stdout</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Fprintf</span><span class="p">(</span><span class="nx">w</span><span class="p">,</span> <span class="s">&quot;hello, writer\n&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="stringers">Stringers</h4>
<p>一个普遍存在的接口是 fmt 包中定义的 Stringer。</p>
<div class="hlcode"><pre><span class="kd">type</span> <span class="nx">Stringer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</pre></div>


<p>Stringer 是一个可以用字符串描述自己的类型。<code>fmt</code>包 （还有许多其他包）使用这个来进行输出。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">type</span> <span class="nx">Person</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">Name</span> <span class="kt">string</span>
    <span class="nx">Age</span>  <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">Person</span><span class="p">)</span> <span class="nx">String</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%v (%v years)&quot;</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">Age</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">a</span> <span class="o">:=</span> <span class="nx">Person</span><span class="p">{</span><span class="s">&quot;Arthur Dent&quot;</span><span class="p">,</span> <span class="mi">42</span><span class="p">}</span>
    <span class="nx">z</span> <span class="o">:=</span> <span class="nx">Person</span><span class="p">{</span><span class="s">&quot;Zaphod Beeblebrox&quot;</span><span class="p">,</span> <span class="mi">9001</span><span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">z</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="_35">错误</h4>
<p>Go 程序使用 error 值来表示错误状态。</p>
<p>与 fmt.Stringer 类似， error 类型是一个内建接口：</p>
<div class="hlcode"><pre><span class="kd">type</span> <span class="kt">error</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">Error</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</pre></div>


<p>（与 fmt.Stringer 类似，fmt 包在输出时也会试图匹配 error。）</p>
<p>通常函数会返回一个 error 值，调用的它的代码应当判断这个错误是否等于 nil， 来进行错误处理。</p>
<div class="hlcode"><pre><span class="nx">i</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">strconv</span><span class="p">.</span><span class="nx">Atoi</span><span class="p">(</span><span class="s">&quot;42&quot;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;couldn&#39;t convert number: %v\n&quot;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
    <span class="k">return</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Converted integer:&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
</pre></div>


<p>error 为 nil 时表示成功；非 nil 的 error 表示错误。</p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;time&quot;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">MyError</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">When</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
    <span class="nx">What</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">e</span> <span class="o">*</span><span class="nx">MyError</span><span class="p">)</span> <span class="nx">Error</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;at %v, %s&quot;</span><span class="p">,</span>
        <span class="nx">e</span><span class="p">.</span><span class="nx">When</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">What</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">run</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">MyError</span><span class="p">{</span>
        <span class="nx">time</span><span class="p">.</span><span class="nx">Now</span><span class="p">(),</span>
        <span class="s">&quot;it didn&#39;t work&quot;</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">run</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h4 id="readers">Readers</h4>
<p>io 包指定了 io.Reader 接口， 它表示从数据流结尾读取。</p>
<p>Go 标准库包含了这个接口的许多实现， 包括文件、网络连接、压缩、加密等等。</p>
<p>io.Reader 接口有一个 Read 方法：</p>
<div class="hlcode"><pre><span class="kd">func</span> <span class="p">(</span><span class="nx">T</span><span class="p">)</span> <span class="nx">Read</span><span class="p">(</span><span class="nx">b</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
</pre></div>


<p>Read 用数据填充指定的字节 slice，并且返回填充的字节数和错误信息。 在遇到数据流结尾时，返回 io.EOF 错误。</p>
<p>例子代码创建了一个 strings.Reader。 并且以每次 8 字节的速度读取它的输出。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;io&quot;</span>
    <span class="s">&quot;strings&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">r</span> <span class="o">:=</span> <span class="nx">strings</span><span class="p">.</span><span class="nx">NewReader</span><span class="p">(</span><span class="s">&quot;Hello, Reader!&quot;</span><span class="p">)</span>

    <span class="nx">b</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">Read</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;n = %v err = %v b = %v\n&quot;</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;b[:n] = %q\n&quot;</span><span class="p">,</span> <span class="nx">b</span><span class="p">[:</span><span class="nx">n</span><span class="p">])</span>
        <span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
            <span class="k">break</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h4 id="web">Web 服务器</h4>
<p>包 <a href="https://go-zh.org/pkg/net/http/">http</a> 通过任何实现了 http.Handler 的值来响应 HTTP 请求：</p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">http</span>

<span class="kd">type</span> <span class="nx">Handler</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">ServeHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">r</span> <span class="o">*</span><span class="nx">Request</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>在这个例子中，类型 Hello 实现了 http.Handler。</p>
<p>访问 <a href="http://localhost:4000/">http://localhost:4000/</a> 会看到来自程序的问候。</p>
<p><em>注意： 这个例子无法在基于 web 的指南用户界面运行。为了尝试编写 web 服务器，可能需要<a href="https://go-zh.org/doc/install/">安装 Go</a>。</em></p>
<h4 id="_36">图片</h4>
<p><a href="https://go-zh.org/pkg/image/#Image">Package image</a> 定义了 Image 接口：</p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">image</span>

<span class="kd">type</span> <span class="nx">Image</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nx">ColorModel</span><span class="p">()</span> <span class="nx">color</span><span class="p">.</span><span class="nx">Model</span>
    <span class="nx">Bounds</span><span class="p">()</span> <span class="nx">Rectangle</span>
    <span class="nx">At</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">color</span><span class="p">.</span><span class="nx">Color</span>
<span class="p">}</span>
</pre></div>


<p>注意：Bounds 方法的 Rectangle 返回值实际上是一个 image.Rectangle， 其定义在 image 包中。</p>
<p>（参阅<a href="https://go-zh.org/pkg/image/#Image">文档</a>了解全部信息。）</p>
<p><code>color.Color</code> 和 <code>color.Model</code> 也是接口，但是通常因为直接使用预定义的实现 image.RGBA 和 <code>image.RGBAModel</code> 而被忽视了。这些接口和类型由<a href="https://go-zh.org/pkg/image/color/">image/color 包</a>定义。</p>
<h2 id="_37">并发</h2>
<h3 id="_38">并发</h3>
<h4 id="goroutine">goroutine</h4>
<p>goroutine 是由 Go 运行时环境管理的轻量级线程。  </p>
<div class="hlcode"><pre><span class="k">go</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">)</span>
</pre></div>


<p>开启一个新的 goroutine 执行 </p>
<div class="hlcode"><pre><span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">)</span>
</pre></div>


<p>f，x，y 和 z 是当前 goroutine 中定义的，但是在新的 goroutine 中运行 f。</p>
<p>goroutine 在相同的地址空间中运行，因此访问共享内存必须进行同步。sync 提供了这种可能，不过在 Go 中并不经常用到，因为有其他的办法。（在接下来的内容中会涉及到。）  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;time&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">say</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">go</span> <span class="nx">say</span><span class="p">(</span><span class="s">&quot;world&quot;</span><span class="p">)</span>
    <span class="nx">say</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="channel">channel</h4>
<p>channel 是有类型的管道，可以用 channel 操作符 &lt;- 对其发送或者接收值。  </p>
<div class="hlcode"><pre><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">v</span>    <span class="c1">// 将 v 送入 channel ch。</span>
<span class="nx">v</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>  <span class="c1">// 从 ch 接收，并且赋值给 v。</span>
</pre></div>


<p>（“箭头”就是数据流的方向。）</p>
<p>和 map 与 slice 一样，channel 使用前必须创建：  </p>
<div class="hlcode"><pre><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
</pre></div>


<p>默认情况下，在另一端准备好之前，发送和接收都会阻塞。这使得 goroutine 可以在没有明确的锁或竞态变量的情况下进行同步。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">c</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">a</span> <span class="p">{</span>
        <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">v</span>
    <span class="p">}</span>
    <span class="nx">c</span> <span class="o">&lt;-</span> <span class="nx">sum</span> <span class="c1">// 将和送入 c</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">a</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">9</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>

    <span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
    <span class="k">go</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span> <span class="nx">c</span><span class="p">)</span>
    <span class="k">go</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">:],</span> <span class="nx">c</span><span class="p">)</span>
    <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">c</span><span class="p">,</span> <span class="o">&lt;-</span><span class="nx">c</span> <span class="c1">// 从 c 中获取</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="o">+</span><span class="nx">y</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="channel_1">缓冲 channel</h4>
<p>channel 可以是 带缓冲的。为 make 提供第二个参数作为缓冲长度来初始化一个缓冲 channel：  </p>
<div class="hlcode"><pre><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</pre></div>


<p>向带缓冲的 channel 发送数据的时候，只有在缓冲区满的时候才会阻塞。 而当缓冲区为空的时候接收操作会阻塞。</p>
<p>修改例子使得缓冲区被填满，然后看看会发生什么。</p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">1</span>
    <span class="nx">ch</span> <span class="o">&lt;-</span> <span class="mi">2</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">ch</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">ch</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="range-close">range 和 close</h4>
<p>发送者可以 close 一个 channel 来表示再没有值会被发送了。接收者可以通过赋值语句的第二参数来测试 channel 是否被关闭：当没有值可以接收并且 channel 已经被关闭，那么经过</p>
<div class="hlcode"><pre><span class="nx">v</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
</pre></div>


<p>之后 ok 会被设置为 false。</p>
<p>循环 <code>for i := range c</code> 会不断从 channel 接收值，直到它被关闭。</p>
<p><em>注意： 只有发送者才能关闭 channel，而不是接收者。向一个已经关闭的 channel 发送数据会引起 panic。</em></p>
<p><em>还要注意： channel 与文件不同；通常情况下无需关闭它们。只有在需要告诉接收者没有更多的数据的时候才有必要进行关闭，例如中断一个 range。</em>  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">fibonacci</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">c</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">c</span> <span class="o">&lt;-</span> <span class="nx">x</span>
        <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">=</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="o">+</span><span class="nx">y</span>
    <span class="p">}</span>
    <span class="nb">close</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="k">go</span> <span class="nx">fibonacci</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span> <span class="nx">c</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h4 id="select">select</h4>
<p>select 语句使得一个 goroutine 在多个通讯操作上等待。</p>
<p>select 会阻塞，直到条件分支中的某个可以继续执行，这时就会执行那个条件分支。当多个都准备好的时候，会随机选择一个。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span> <span class="nx">fibonacci</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">quit</span> <span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nx">c</span> <span class="o">&lt;-</span> <span class="nx">x</span><span class="p">:</span>
            <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="p">=</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="o">+</span><span class="nx">y</span>
        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">quit</span><span class="p">:</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;quit&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
    <span class="nx">quit</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">c</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">quit</span> <span class="o">&lt;-</span> <span class="mi">0</span>
    <span class="p">}()</span>
    <span class="nx">fibonacci</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">quit</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h4 id="_39">默认选择</h4>
<p>当 select 中的其他条件分支都没有准备好的时候，default 分支会被执行。</p>
<p>为了非阻塞的发送或者接收，可使用 default 分支：  </p>
<div class="hlcode"><pre><span class="k">select</span> <span class="p">{</span>
<span class="k">case</span> <span class="nx">i</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">c</span><span class="p">:</span>
    <span class="c1">// 使用 i</span>
<span class="k">default</span><span class="p">:</span>
    <span class="c1">// 从 c 读取会阻塞</span>
<span class="p">}</span>
</pre></div>


<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;time&quot;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">tick</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Tick</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
    <span class="nx">boom</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">After</span><span class="p">(</span><span class="mi">500</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">tick</span><span class="p">:</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;tick.&quot;</span><span class="p">)</span>
        <span class="k">case</span> <span class="o">&lt;-</span><span class="nx">boom</span><span class="p">:</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;BOOM!&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;    .&quot;</span><span class="p">)</span>
            <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="mi">50</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h4 id="syncmutex">sync.Mutex</h4>
<p>sync.Mutex<br />
我们已经看到 channel 用来在各个 goroutine 间进行通信是非常合适的了。</p>
<p>但是如果我们并不需要通信呢？比如说，如果我们只是想保证在每个时刻，只有一个 goroutine 能访问一个共享的变量从而避免冲突？</p>
<p>这里涉及的概念叫做 互斥，通常使用 <em>互斥锁</em>(mutex)_来提供这个限制。</p>
<p>Go 标准库中提供了 sync.Mutex 类型及其两个方法：</p>
<div class="hlcode"><pre><span class="nx">Lock</span>
<span class="nx">Unlock</span>
</pre></div>


<p>我们可以通过在代码前调用 <code>Lock</code> 方法，在代码后调用 <code>Unlock</code> 方法来保证一段代码的互斥执行。 参见 Inc 方法。</p>
<p>我们也可以用 <code>defer</code> 语句来保证互斥锁一定会被解锁。参见 <code>Value</code> 方法。  </p>
<div class="hlcode"><pre><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;sync&quot;</span>
    <span class="s">&quot;time&quot;</span>
<span class="p">)</span>

<span class="c1">// SafeCounter 的并发使用是安全的。</span>
<span class="kd">type</span> <span class="nx">SafeCounter</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">v</span>   <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span>
    <span class="nx">mux</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="p">}</span>

<span class="c1">// Inc 增加给定 key 的计数器的值。</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">SafeCounter</span><span class="p">)</span> <span class="nx">Inc</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">mux</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
    <span class="c1">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">v</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span><span class="o">++</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">mux</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// Value 返回给定 key 的计数器的当前值。</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">SafeCounter</span><span class="p">)</span> <span class="nx">Value</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">c</span><span class="p">.</span><span class="nx">mux</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
    <span class="c1">// Lock 之后同一时刻只有一个 goroutine 能访问 c.v</span>
    <span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nx">mux</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
    <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">v</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">c</span> <span class="o">:=</span> <span class="nx">SafeCounter</span><span class="p">{</span><span class="nx">v</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">int</span><span class="p">)}</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="nx">c</span><span class="p">.</span><span class="nx">Inc</span><span class="p">(</span><span class="s">&quot;somekey&quot;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">Value</span><span class="p">(</span><span class="s">&quot;somekey&quot;</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
  
  <div class="relation">
    Related:
    <ul>
  
    <li><a href="/go/go-vscode.html">Go VSCode配置</a></li>
  
    </ul>
  </div>
  
</div>
    </div>
    <div id="footer">
      <div class="footer-left">
        <p>
        Copyright © 2025 <a href='https://dongfg.com'>dongfg</a>.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
        Theme by <a href="https://git.coding.net/tankywoo/yasimple_x2.git" target="_blank">YASimple_X2</a>.
        </p>
      </div> <!-- end footer-left -->
      <div class="footer-right">
        <p>Site Generated 2025-12-24 13:53:58</p>
      </div> <!-- end footer-right -->
    </div>

    
    
  </body>
</html>